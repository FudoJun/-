//优先队列，小的在前


#ifndef LINKEDLIST_PRIORITYQUEQUE_H
#define LINKEDLIST_PRIORITYQUEQUE_H

#include <iostream>

///////////////////////// 声明 //////////////////////////

template<typename K, typename V>
class Node{
public:
    K key;
    V value;
    Node* next;

    Node(const V& v = V(), const K& k = K())
        : key{k}, value{v}, next{nullptr} {}

};

template<typename K, typename V>
class PriorityQueue{
private:
    Node<K,V>* front;
    //Node<K,V>* rear;

public:
    PriorityQueue() : front{nullptr} {}
    ~PriorityQueue();

    void enqueue(const V& value, const K& key = K());   //不传K的时候使用默认值，主要用于构建哈夫曼树的根节点
    Node<K,V> dequeue();
    bool isEmpty() const;
    void printQueue() const;

};

///////////////////////// 实现 //////////////////////////

template<typename K, typename V>
PriorityQueue<K,V>::~PriorityQueue() {
    while (front){
        Node<K,V>* temp = front;
        front = front->next;
        delete temp;
    }
}

template<typename K, typename V>
bool PriorityQueue<K, V>::isEmpty() const {
    return front == nullptr;
}

template<typename K, typename V>
void PriorityQueue<K, V>::enqueue(const V& value, const K& key) {
    Node<K,V>* newNode = new Node<K,V>(value,key);
    if (!front || value < front->value){
        newNode->next = front;
        front = newNode;
    } else{
        Node<K,V>* current = front;
        while (current->next && current->next->value <= value){
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }
}

template<typename K, typename V>
Node<K, V> PriorityQueue<K, V>::dequeue() {
    if (isEmpty()){
        std::cerr<<"Queue is empty."<<std::endl;
        return Node<K,V>();
    }
    Node<K,V> tempObj = *front;
    Node<K,V>* temp = front;
    front = front->next;
    delete temp;
    return tempObj;
}

template<typename K,typename V>
void PriorityQueue<K, V>::printQueue() const {
    Node<K,V>* current = front;
    std::cout<<"<<<| ";
    while (current){
        std::cout<<current->key<<" ";
        current = current->next;
    }
    std::cout<<" |<<<"<<std::endl;
}

#endif //LINKEDLIST_PRIORITYQUEQUE_H
